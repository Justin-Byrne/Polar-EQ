"use strict";

const { textBetween } = require ( "../utils/tokens" );

/**
 * Operators that must be surrounded by whitespace (excluding ":" â€”
 * colons are handled only by checkColon with context).
 */
const WIDEBAND_OPERATORS = new Set (
[
    "!==", "===", "<<=", ">>=", ">>>=", "&&=", "||=", "??=",
    "<=", ">=", "!=", "==",
    "&&", "||", "??",
    "+=", "-=", "*=", "/=", "%=", "&=", "|=", "^=",
    "<<", ">>",
    "=>",
    "<", ">", "=",
    "+", "-",
    "*", "/", "%",
    "&", "|", "^",
    "?",
    "{", "["
] );

/**
 * Detect unary + and - operators.
 */
function isUnaryPlusMinus ( prevToken )
{
    if ( ! prevToken ) return true;

    const _binaryBefore = new Set (
    [
        ")",
        "]",
        "}",
        "Identifier",
        "Numeric",
        "String",
        "Template",
        "RegularExpression"
    ] );

    if ( _binaryBefore.has ( prevToken.type ) || _binaryBefore.has ( prevToken.value ) )
    {
        return false;
    }

    if ( prevToken.type === "Identifier" ||
         prevToken.type === "Numeric"    ||
         prevToken.type === "String"     ||
         prevToken.type === "Template"   ||
         prevToken.type === "RegularExpression" )
    {
        return false;
    }

    return true;
}

/**
 * Enforce whitespace around binary operator tokens.
 */
function enforceOperatorSpacing ( context, token, prev, next )
{
    if ( ! prev || ! next ) return;

    const _sourceCode = context.sourceCode;
    const _before     = textBetween ( _sourceCode, prev, token );
    const _after      = textBetween ( _sourceCode, token, next );

    if ( !/\s/.test ( _before ) || !/\s/.test ( _after ) )
    {
        context.report (
        {
            loc: token.loc,
            message: `Operator "${token.value}" must be surrounded by whitespace (Wideband rule).`
        } );
    }
}

/**
 * Global operator scanner for all non-colon operators in the file.
 */
function scanOperators ( context )
{
    const _sourceCode = context.sourceCode;
    const _tokens     = _sourceCode.tokensAndComments;

    for ( let _i = 0; _i < _tokens.length; _i++ )
    {
        const _token = _tokens [ _i ];

        // ðŸš« HARD BLOCK: prevent colon from EVER being treated as an operator.
        // This fixes TS return types, type annotations, object properties,
        // and ternaries from being incorrectly flagged.
        if ( _token.value === ":" ) continue;

        if ( ! WIDEBAND_OPERATORS.has ( _token.value ) ) continue;

        const _prev = _tokens [ _i - 1 ] || null;
        const _next = _tokens [ _i + 1 ] || null;

        // Unary +/-
        if ( ( _token.value === "+" || _token.value === "-" ) && isUnaryPlusMinus ( _prev ) )
        {
            continue;
        }

        enforceOperatorSpacing ( context, _token, _prev, _next );
    }
}

function checkColon ( context, colonToken )
{
    const _sourceCode = context.sourceCode;
    const _next       = _sourceCode.getTokenAfter ( colonToken );

    if ( ! _next ) return;

    const _gap = textBetween ( _sourceCode, colonToken, _next );

    if ( /^\s*\n\s*$/.test ( _gap ) ) return;

    if ( /^ +$/.test ( _gap ) ) return;

    context.report (
    {
        loc: colonToken.loc,
        message: "Colon must be followed by a space."
    } );
}

/**
 * Comma spacing.
 */
function checkComma ( context, commaToken )
{
    const _sourceCode = context.sourceCode;
    const _next       = _sourceCode.getTokenAfter ( commaToken );

    if ( ! _next ) return;

    const _gap = textBetween ( _sourceCode, commaToken, _next );

    if ( /^\s*\n\s*$/.test ( _gap ) ) return;

    if ( /^ +$/.test ( _gap ) ) return;

    context.report (
    {
        loc: commaToken.loc,
        message: "Comma must be followed by a space or newline."
    } );
}

/**
 * Parenthesis spacing rules.
 */
function checkOpenParen ( context, openToken )
{
    const _sourceCode = context.sourceCode;
    const _prev       = _sourceCode.getTokenBefore ( openToken );
    const _next       = _sourceCode.getTokenAfter ( openToken );

    if ( ! _next ) return;

    const _needsSpaceBefore = _prev && ( _prev.type === "Identifier" ||
                                         _prev.type === "Keyword"    ||
                                         _prev.value === ")"         ||
                                         _prev.value === "]"         ||
                                         _prev.value === "}"         ||
                                         _prev.value === ">" );

    if ( _needsSpaceBefore )
    {
        const _gapBefore = textBetween ( _sourceCode, _prev, openToken );

        if ( !/^ +$/.test ( _gapBefore ) )
        {
            context.report (
            {
                loc: openToken.loc,
                message: "Opening parenthesis must be preceded by a space in Wideband style."
            } );
        }
    }

    const _gapAfter = textBetween ( _sourceCode, openToken, _next );

    if ( /^\s*\n\s*$/.test ( _gapAfter ) ) return;

    if ( !/^ +$/.test ( _gapAfter ) )
    {
        context.report (
        {
            loc: openToken.loc,
            message: "Opening parenthesis must be followed by a space in Wideband style."
        } );
    }
}

function checkCloseParen ( context, closeToken )
{
    const _sourceCode = context.sourceCode;
    const _prev       = _sourceCode.getTokenBefore ( closeToken );
    const _next       = _sourceCode.getTokenAfter ( closeToken );

    if ( ! _prev ) return;

    const _gapBefore  = textBetween ( _sourceCode, _prev, closeToken );
    const _isSameLine = _prev.loc.end.line === closeToken.loc.start.line;

    if ( _prev.value !== "(" && _isSameLine )
    {
        if ( !/^ +$/.test ( _gapBefore ) )
        {
            context.report (
            {
                loc: closeToken.loc,
                message: "Closing parenthesis must be preceded by a space in Wideband style."
            } );
        }
    }

    if ( ! _next ) return;

    const _gapAfter        = textBetween ( _sourceCode, closeToken, _next );
    const _needsSpaceAfter = _next && ( _next.type === "Identifier" ||
                                        _next.type === "Keyword"    ||
                                        WIDEBAND_OPERATORS.has ( _next.value ) );

    if ( closeToken.value === "}" ) return;

    if ( _needsSpaceAfter )
    {
        if ( /^\s*\n\s*$/.test ( _gapAfter ) ) return;

        if ( !/^ +$/.test ( _gapAfter ) )
        {
            context.report (
            {
                loc: closeToken.loc,
                message: "Closing parenthesis must be followed by a space or newline in Wideband style."
            } );
        }
    }
}

/**
 * Scan commas, colons, parentheses.
 */
function scanTokens ( context )
{
    const _sourceCode = context.sourceCode;
    const _tokens     = _sourceCode.tokensAndComments;

    for ( const _token of _tokens )
    {
        if ( _token.value === "," ) checkComma ( context, _token );
        if ( _token.value === ":" ) checkColon ( context, _token );
        if ( _token.value === "(" ) checkOpenParen ( context, _token );
        if ( _token.value === ")" ) checkCloseParen ( context, _token );
        if ( _token.value === "]" ) checkCloseParen ( context, _token );
        if ( _token.value === "}" ) checkCloseParen ( context, _token );
    }
}

/**
 * Rule entry point.
 */
module.exports =
{
    meta:
    {
        type: "layout",
        docs:
        {
            description: "Wideband spacing for operators, parentheses, commas, and colons."
        },
        schema: [ ],
        fixable: "whitespace"
    },

    create ( context )
    {
        return {
            "Program:exit" ( )
            {
                scanTokens ( context );     // commas, colons, parens
                scanOperators ( context );  // all non-colon operators (+ HARD BLOCK)
            }
        };
    }
};
