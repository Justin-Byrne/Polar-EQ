"use strict";

module.exports =
{
    meta:
    {
        type: "layout",
        docs:
        {
            description: "Enforce Allman brace style for classes, functions, and conditionals.",
            recommended: false,
        },
        schema: [ ],
        fixable: "code",
    },

    create ( context )
    {
        const _sourceCode = context.getSourceCode ( );

        /**
         * Checks that the given opening brace token is on a new line,
         * not sharing a line with the previous token.
         */
        function enforceAllman ( braceToken )
        {
            const _prevToken = _sourceCode.getTokenBefore ( braceToken );

            if ( ! _prevToken ) return;

            if ( _prevToken.loc.end.line === braceToken.loc.start.line )
            {
                context.report (
                {
                    loc: braceToken.loc,
                    message: "Opening brace must be on its own line (Allman style).",
                    fix ( fixer )
                    {
                        const textBetween      = _sourceCode.text.slice ( _prevToken.range [ 1 ], braceToken.range [ 0 ] );

                        // Replace text between with newline + existing indentation from brace line
                        const _beforeBraceLine  = _sourceCode.lines [ braceToken.loc.start.line - 1 ];
                        const _indentationMatch = _beforeBraceLine.match ( /^\s*/ );
                        const _indent           = _indentationMatch ? _indentationMatch [ 0 ] : "";

                        return fixer.replaceTextRange ( [ _prevToken.range [ 1 ], braceToken.range [ 0 ] ], "\n" + _indent );
                    },
                } );
            }
        }

        function checkNodeWithBody ( node )
        {
            if ( ! node.body ) return;

            let _braceOwner = node.body;

            if ( _braceOwner.type !== "BlockStatement" && _braceOwner.type !== "ClassBody" )
            {
                return;
            }

            const _braceToken = _sourceCode.getFirstToken ( _braceOwner, token => token.value === "{" );

            if ( ! _braceToken ) return;

            enforceAllman ( _braceToken );
        }

        return {
            FunctionDeclaration:     checkNodeWithBody,
            FunctionExpression:      checkNodeWithBody,
            ArrowFunctionExpression: checkNodeWithBody,
            IfStatement:             checkNodeWithBody,
            ForStatement:            checkNodeWithBody,
            ForInStatement:          checkNodeWithBody,
            ForOfStatement:          checkNodeWithBody,
            WhileStatement:          checkNodeWithBody,
            DoWhileStatement:        checkNodeWithBody,
            ClassDeclaration:        checkNodeWithBody,
            ClassExpression:         checkNodeWithBody,
        };
    },
};
